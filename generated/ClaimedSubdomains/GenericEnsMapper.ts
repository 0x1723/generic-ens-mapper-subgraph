// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class AddrChanged extends ethereum.Event {
  get params(): AddrChanged__Params {
    return new AddrChanged__Params(this);
  }
}

export class AddrChanged__Params {
  _event: AddrChanged;

  constructor(event: AddrChanged) {
    this._event = event;
  }

  get node(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get a(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class AddressChanged extends ethereum.Event {
  get params(): AddressChanged__Params {
    return new AddressChanged__Params(this);
  }
}

export class AddressChanged__Params {
  _event: AddressChanged;

  constructor(event: AddressChanged) {
    this._event = event;
  }

  get node(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get coinType(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get newAddress(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class NameChanged extends ethereum.Event {
  get params(): NameChanged__Params {
    return new NameChanged__Params(this);
  }
}

export class NameChanged__Params {
  _event: NameChanged;

  constructor(event: NameChanged) {
    this._event = event;
  }

  get node(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get name(): string {
    return this._event.parameters[1].value.toString();
  }
}

export class SubdomainClaimed extends ethereum.Event {
  get params(): SubdomainClaimed__Params {
    return new SubdomainClaimed__Params(this);
  }
}

export class SubdomainClaimed__Params {
  _event: SubdomainClaimed;

  constructor(event: SubdomainClaimed) {
    this._event = event;
  }

  get _nodeHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get _nftContract(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _name(): string {
    return this._event.parameters[3].value.toString();
  }
}

export class SubdomainRemoved extends ethereum.Event {
  get params(): SubdomainRemoved__Params {
    return new SubdomainRemoved__Params(this);
  }
}

export class SubdomainRemoved__Params {
  _event: SubdomainRemoved;

  constructor(event: SubdomainRemoved) {
    this._event = event;
  }

  get _nodeHash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get _nftContract(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _name(): string {
    return this._event.parameters[3].value.toString();
  }
}

export class TextChanged extends ethereum.Event {
  get params(): TextChanged__Params {
    return new TextChanged__Params(this);
  }
}

export class TextChanged__Params {
  _event: TextChanged;

  constructor(event: TextChanged) {
    this._event = event;
  }

  get node(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get indexedKey(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get key(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class addNftContractToEns extends ethereum.Event {
  get params(): addNftContractToEns__Params {
    return new addNftContractToEns__Params(this);
  }
}

export class addNftContractToEns__Params {
  _event: addNftContractToEns;

  constructor(event: addNftContractToEns) {
    this._event = event;
  }

  get _ensId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _nftContract(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class updateEnsClaimConfig extends ethereum.Event {
  get params(): updateEnsClaimConfig__Params {
    return new updateEnsClaimConfig__Params(this);
  }
}

export class updateEnsClaimConfig__Params {
  _event: updateEnsClaimConfig;

  constructor(event: updateEnsClaimConfig) {
    this._event = event;
  }

  get _ensId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _numericOnly(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }

  get _canOverwriteSubdomains(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class GenericEnsMapper__EnsToConfigResult {
  value0: boolean;
  value1: boolean;
  value2: boolean;

  constructor(value0: boolean, value1: boolean, value2: boolean) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromBoolean(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    return map;
  }

  getInitialised(): boolean {
    return this.value0;
  }

  getNumericOnly(): boolean {
    return this.value1;
  }

  getCanOverwriteSubdomains(): boolean {
    return this.value2;
  }
}

export class GenericEnsMapper__ParentNodeToConfigResult {
  value0: boolean;
  value1: boolean;
  value2: boolean;

  constructor(value0: boolean, value1: boolean, value2: boolean) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromBoolean(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    return map;
  }

  getInitialised(): boolean {
    return this.value0;
  }

  getNumericOnly(): boolean {
    return this.value1;
  }

  getCanOverwriteSubdomains(): boolean {
    return this.value2;
  }
}

export class GenericEnsMapper__SubnodeToNftDetailsResult {
  value0: BigInt;
  value1: string;
  value2: Address;
  value3: BigInt;

  constructor(value0: BigInt, value1: string, value2: Address, value3: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromString(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    return map;
  }

  getParentTokenId(): BigInt {
    return this.value0;
  }

  getLabel(): string {
    return this.value1;
  }

  getNftAddress(): Address {
    return this.value2;
  }

  getNftId(): BigInt {
    return this.value3;
  }
}

export class GenericEnsMapper extends ethereum.SmartContract {
  static bind(address: Address): GenericEnsMapper {
    return new GenericEnsMapper("GenericEnsMapper", address);
  }

  EnsContract(): Address {
    let result = super.call("EnsContract", "EnsContract():(address)", []);

    return result[0].toAddress();
  }

  try_EnsContract(): ethereum.CallResult<Address> {
    let result = super.tryCall("EnsContract", "EnsContract():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  EnsNameWrapper(): Address {
    let result = super.call("EnsNameWrapper", "EnsNameWrapper():(address)", []);

    return result[0].toAddress();
  }

  try_EnsNameWrapper(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "EnsNameWrapper",
      "EnsNameWrapper():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  EnsToConfig(param0: Bytes): GenericEnsMapper__EnsToConfigResult {
    let result = super.call(
      "EnsToConfig",
      "EnsToConfig(bytes32):(bool,bool,bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return new GenericEnsMapper__EnsToConfigResult(
      result[0].toBoolean(),
      result[1].toBoolean(),
      result[2].toBoolean()
    );
  }

  try_EnsToConfig(
    param0: Bytes
  ): ethereum.CallResult<GenericEnsMapper__EnsToConfigResult> {
    let result = super.tryCall(
      "EnsToConfig",
      "EnsToConfig(bytes32):(bool,bool,bool)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new GenericEnsMapper__EnsToConfigResult(
        value[0].toBoolean(),
        value[1].toBoolean(),
        value[2].toBoolean()
      )
    );
  }

  EnsToken(): Address {
    let result = super.call("EnsToken", "EnsToken():(address)", []);

    return result[0].toAddress();
  }

  try_EnsToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("EnsToken", "EnsToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  ParentNodeToConfig(
    param0: BigInt
  ): GenericEnsMapper__ParentNodeToConfigResult {
    let result = super.call(
      "ParentNodeToConfig",
      "ParentNodeToConfig(uint256):(bool,bool,bool)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return new GenericEnsMapper__ParentNodeToConfigResult(
      result[0].toBoolean(),
      result[1].toBoolean(),
      result[2].toBoolean()
    );
  }

  try_ParentNodeToConfig(
    param0: BigInt
  ): ethereum.CallResult<GenericEnsMapper__ParentNodeToConfigResult> {
    let result = super.tryCall(
      "ParentNodeToConfig",
      "ParentNodeToConfig(uint256):(bool,bool,bool)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new GenericEnsMapper__ParentNodeToConfigResult(
        value[0].toBoolean(),
        value[1].toBoolean(),
        value[2].toBoolean()
      )
    );
  }

  ParentNodeToNftContracts(param0: BigInt, param1: BigInt): Address {
    let result = super.call(
      "ParentNodeToNftContracts",
      "ParentNodeToNftContracts(uint256,uint256):(address)",
      [
        ethereum.Value.fromUnsignedBigInt(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toAddress();
  }

  try_ParentNodeToNftContracts(
    param0: BigInt,
    param1: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "ParentNodeToNftContracts",
      "ParentNodeToNftContracts(uint256,uint256):(address)",
      [
        ethereum.Value.fromUnsignedBigInt(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  REVERSE_REGISTRAR(): Address {
    let result = super.call(
      "REVERSE_REGISTRAR",
      "REVERSE_REGISTRAR():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_REVERSE_REGISTRAR(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "REVERSE_REGISTRAR",
      "REVERSE_REGISTRAR():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  SubdomainClaimMap(param0: Bytes): Bytes {
    let result = super.call(
      "SubdomainClaimMap",
      "SubdomainClaimMap(bytes32):(bytes32)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBytes();
  }

  try_SubdomainClaimMap(param0: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "SubdomainClaimMap",
      "SubdomainClaimMap(bytes32):(bytes32)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  SubnodeToNftDetails(
    param0: Bytes
  ): GenericEnsMapper__SubnodeToNftDetailsResult {
    let result = super.call(
      "SubnodeToNftDetails",
      "SubnodeToNftDetails(bytes32):(uint256,string,address,uint96)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return new GenericEnsMapper__SubnodeToNftDetailsResult(
      result[0].toBigInt(),
      result[1].toString(),
      result[2].toAddress(),
      result[3].toBigInt()
    );
  }

  try_SubnodeToNftDetails(
    param0: Bytes
  ): ethereum.CallResult<GenericEnsMapper__SubnodeToNftDetailsResult> {
    let result = super.tryCall(
      "SubnodeToNftDetails",
      "SubnodeToNftDetails(bytes32):(uint256,string,address,uint96)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new GenericEnsMapper__SubnodeToNftDetailsResult(
        value[0].toBigInt(),
        value[1].toString(),
        value[2].toAddress(),
        value[3].toBigInt()
      )
    );
  }

  addr(node: Bytes): Address {
    let result = super.call("addr", "addr(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(node)
    ]);

    return result[0].toAddress();
  }

  try_addr(node: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("addr", "addr(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(node)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  addr1(node: Bytes, coinType: BigInt): Bytes {
    let result = super.call("addr", "addr(bytes32,uint256):(bytes)", [
      ethereum.Value.fromFixedBytes(node),
      ethereum.Value.fromUnsignedBigInt(coinType)
    ]);

    return result[0].toBytes();
  }

  try_addr1(node: Bytes, coinType: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall("addr", "addr(bytes32,uint256):(bytes)", [
      ethereum.Value.fromFixedBytes(node),
      ethereum.Value.fromUnsignedBigInt(coinType)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getDomainHash(_domainArray: Array<string>): Bytes {
    let result = super.call(
      "getDomainHash",
      "getDomainHash(string[]):(bytes32)",
      [ethereum.Value.fromStringArray(_domainArray)]
    );

    return result[0].toBytes();
  }

  try_getDomainHash(_domainArray: Array<string>): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getDomainHash",
      "getDomainHash(string[]):(bytes32)",
      [ethereum.Value.fromStringArray(_domainArray)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  name(node: Bytes): string {
    let result = super.call("name", "name(bytes32):(string)", [
      ethereum.Value.fromFixedBytes(node)
    ]);

    return result[0].toString();
  }

  try_name(node: Bytes): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name(bytes32):(string)", [
      ethereum.Value.fromFixedBytes(node)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  namehashFromId(_id: BigInt): Bytes {
    let result = super.call(
      "namehashFromId",
      "namehashFromId(uint256):(bytes32)",
      [ethereum.Value.fromUnsignedBigInt(_id)]
    );

    return result[0].toBytes();
  }

  try_namehashFromId(_id: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "namehashFromId",
      "namehashFromId(uint256):(bytes32)",
      [ethereum.Value.fromUnsignedBigInt(_id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC1155BatchReceived(
    param0: Address,
    param1: Address,
    param2: Array<BigInt>,
    param3: Array<BigInt>,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155BatchReceived",
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigIntArray(param2),
        ethereum.Value.fromUnsignedBigIntArray(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155BatchReceived(
    param0: Address,
    param1: Address,
    param2: Array<BigInt>,
    param3: Array<BigInt>,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155BatchReceived",
      "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigIntArray(param2),
        ethereum.Value.fromUnsignedBigIntArray(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_onERC1155Received(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "onERC1155Received",
      "onERC1155Received(address,address,uint256,uint256,bytes):(bytes4)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  text(node: Bytes, key: string): string {
    let result = super.call("text", "text(bytes32,string):(string)", [
      ethereum.Value.fromFixedBytes(node),
      ethereum.Value.fromString(key)
    ]);

    return result[0].toString();
  }

  try_text(node: Bytes, key: string): ethereum.CallResult<string> {
    let result = super.tryCall("text", "text(bytes32,string):(string)", [
      ethereum.Value.fromFixedBytes(node),
      ethereum.Value.fromString(key)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddContractToExistingEnsCall extends ethereum.Call {
  get inputs(): AddContractToExistingEnsCall__Inputs {
    return new AddContractToExistingEnsCall__Inputs(this);
  }

  get outputs(): AddContractToExistingEnsCall__Outputs {
    return new AddContractToExistingEnsCall__Outputs(this);
  }
}

export class AddContractToExistingEnsCall__Inputs {
  _call: AddContractToExistingEnsCall;

  constructor(call: AddContractToExistingEnsCall) {
    this._call = call;
  }

  get _ensId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _nftContract(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class AddContractToExistingEnsCall__Outputs {
  _call: AddContractToExistingEnsCall;

  constructor(call: AddContractToExistingEnsCall) {
    this._call = call;
  }
}

export class AddEnsContractMappingCall extends ethereum.Call {
  get inputs(): AddEnsContractMappingCall__Inputs {
    return new AddEnsContractMappingCall__Inputs(this);
  }

  get outputs(): AddEnsContractMappingCall__Outputs {
    return new AddEnsContractMappingCall__Outputs(this);
  }
}

export class AddEnsContractMappingCall__Inputs {
  _call: AddEnsContractMappingCall;

  constructor(call: AddEnsContractMappingCall) {
    this._call = call;
  }

  get _domainArray(): Array<string> {
    return this._call.inputValues[0].value.toStringArray();
  }

  get _ensId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _nftContracts(): Array<Address> {
    return this._call.inputValues[2].value.toAddressArray();
  }

  get _numericOnly(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }

  get _overWriteUnusedSubdomains(): boolean {
    return this._call.inputValues[4].value.toBoolean();
  }
}

export class AddEnsContractMappingCall__Outputs {
  _call: AddEnsContractMappingCall;

  constructor(call: AddEnsContractMappingCall) {
    this._call = call;
  }
}

export class ClaimSubdomainCall extends ethereum.Call {
  get inputs(): ClaimSubdomainCall__Inputs {
    return new ClaimSubdomainCall__Inputs(this);
  }

  get outputs(): ClaimSubdomainCall__Outputs {
    return new ClaimSubdomainCall__Outputs(this);
  }
}

export class ClaimSubdomainCall__Inputs {
  _call: ClaimSubdomainCall;

  constructor(call: ClaimSubdomainCall) {
    this._call = call;
  }

  get _ensId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _nftId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _nftContract(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _label(): string {
    return this._call.inputValues[3].value.toString();
  }
}

export class ClaimSubdomainCall__Outputs {
  _call: ClaimSubdomainCall;

  constructor(call: ClaimSubdomainCall) {
    this._call = call;
  }
}

export class OutputEventsCall extends ethereum.Call {
  get inputs(): OutputEventsCall__Inputs {
    return new OutputEventsCall__Inputs(this);
  }

  get outputs(): OutputEventsCall__Outputs {
    return new OutputEventsCall__Outputs(this);
  }
}

export class OutputEventsCall__Inputs {
  _call: OutputEventsCall;

  constructor(call: OutputEventsCall) {
    this._call = call;
  }

  get _subnodeHash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class OutputEventsCall__Outputs {
  _call: OutputEventsCall;

  constructor(call: OutputEventsCall) {
    this._call = call;
  }
}

export class RemoveSubdomainCall extends ethereum.Call {
  get inputs(): RemoveSubdomainCall__Inputs {
    return new RemoveSubdomainCall__Inputs(this);
  }

  get outputs(): RemoveSubdomainCall__Outputs {
    return new RemoveSubdomainCall__Outputs(this);
  }
}

export class RemoveSubdomainCall__Inputs {
  _call: RemoveSubdomainCall;

  constructor(call: RemoveSubdomainCall) {
    this._call = call;
  }

  get _subdomainHash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class RemoveSubdomainCall__Outputs {
  _call: RemoveSubdomainCall;

  constructor(call: RemoveSubdomainCall) {
    this._call = call;
  }
}

export class SetAddrCall extends ethereum.Call {
  get inputs(): SetAddrCall__Inputs {
    return new SetAddrCall__Inputs(this);
  }

  get outputs(): SetAddrCall__Outputs {
    return new SetAddrCall__Outputs(this);
  }
}

export class SetAddrCall__Inputs {
  _call: SetAddrCall;

  constructor(call: SetAddrCall) {
    this._call = call;
  }

  get node(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get coinType(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get a(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class SetAddrCall__Outputs {
  _call: SetAddrCall;

  constructor(call: SetAddrCall) {
    this._call = call;
  }
}

export class SetNameWrapperCall extends ethereum.Call {
  get inputs(): SetNameWrapperCall__Inputs {
    return new SetNameWrapperCall__Inputs(this);
  }

  get outputs(): SetNameWrapperCall__Outputs {
    return new SetNameWrapperCall__Outputs(this);
  }
}

export class SetNameWrapperCall__Inputs {
  _call: SetNameWrapperCall;

  constructor(call: SetNameWrapperCall) {
    this._call = call;
  }

  get _addr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetNameWrapperCall__Outputs {
  _call: SetNameWrapperCall;

  constructor(call: SetNameWrapperCall) {
    this._call = call;
  }
}

export class SetPrimaryNameCall extends ethereum.Call {
  get inputs(): SetPrimaryNameCall__Inputs {
    return new SetPrimaryNameCall__Inputs(this);
  }

  get outputs(): SetPrimaryNameCall__Outputs {
    return new SetPrimaryNameCall__Outputs(this);
  }
}

export class SetPrimaryNameCall__Inputs {
  _call: SetPrimaryNameCall;

  constructor(call: SetPrimaryNameCall) {
    this._call = call;
  }

  get _ens(): string {
    return this._call.inputValues[0].value.toString();
  }
}

export class SetPrimaryNameCall__Outputs {
  _call: SetPrimaryNameCall;

  constructor(call: SetPrimaryNameCall) {
    this._call = call;
  }
}

export class SetTextCall extends ethereum.Call {
  get inputs(): SetTextCall__Inputs {
    return new SetTextCall__Inputs(this);
  }

  get outputs(): SetTextCall__Outputs {
    return new SetTextCall__Outputs(this);
  }
}

export class SetTextCall__Inputs {
  _call: SetTextCall;

  constructor(call: SetTextCall) {
    this._call = call;
  }

  get node(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get key(): string {
    return this._call.inputValues[1].value.toString();
  }

  get value(): string {
    return this._call.inputValues[2].value.toString();
  }
}

export class SetTextCall__Outputs {
  _call: SetTextCall;

  constructor(call: SetTextCall) {
    this._call = call;
  }
}

export class UpdateSettingsToExistingEnsCall extends ethereum.Call {
  get inputs(): UpdateSettingsToExistingEnsCall__Inputs {
    return new UpdateSettingsToExistingEnsCall__Inputs(this);
  }

  get outputs(): UpdateSettingsToExistingEnsCall__Outputs {
    return new UpdateSettingsToExistingEnsCall__Outputs(this);
  }
}

export class UpdateSettingsToExistingEnsCall__Inputs {
  _call: UpdateSettingsToExistingEnsCall;

  constructor(call: UpdateSettingsToExistingEnsCall) {
    this._call = call;
  }

  get _ensId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _numericOnly(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get _overwriteUnusedSubdomains(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class UpdateSettingsToExistingEnsCall__Outputs {
  _call: UpdateSettingsToExistingEnsCall;

  constructor(call: UpdateSettingsToExistingEnsCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}
